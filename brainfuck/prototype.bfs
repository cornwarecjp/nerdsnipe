################################################################################

#32-bit position shifts
>1(){>>>>}
<1(){<<<<}
>2(){>1()>1()}
<2(){<1()<1()}
>4(){>2()>2()}
<4(){<2()<2()}
>8(){>4()>4()}
<8(){<4()<4()}
>16(){>8()>8()}
<16(){<8()<8()}


#Memory map
h0(){}
h1(){h0() >1()}
h2(){h0() >1() >1()}
h3(){h0() >1() >1() >1()}
h4(){h0() >1() >1() >1() >1()}
h5(){h0() >1() >1() >1() >1() >1()}
h6(){h0() >1() >1() >1() >1() >1() >1()}
h7(){h0() >1() >1() >1() >1() >1() >1() >1()}

s0(){h0() >8()}
s1(){s0() >1()}
ch(){s1() >1()}
maj(){ch() >1()}
temp1(){maj() >1()}
temp2(){temp1() >1()}

a(){temp2() >1()}
b(){a() >1()}
c(){b() >1()}
d(){c() >1()}
e(){d() >1()}
f(){e() >1()}
g(){f() >1()}
h(){g() >1()}

stack0(){h() >1()}
stack1(){stack0() >1()}
stack2(){stack1() >1()}
stack3(){stack2() >1()}

A(){stack3() >1()}
#Actual data in A starts 7 bytes later

#In A:
#w = 0x00..0x3f
w0(x;temp0){zero8(x)}
#k = 0x40..0x7f
k0(x;temp0){const8(x;+4();+0();temp0)}

#Note 1: All variables are 32 bit unsigned integers and addition is calculated modulo 232
#Note 2: For each round, there is one round constant k[i] and one entry in the message schedule array w[i], 0 ≤ i ≤ 63
#Note 3: The compression function uses 8 working variables, a through h
#Note 4: Big-endian convention is used when expressing the constants in this pseudocode,
#    and when parsing message block data from bytes to words, for example,
#    the first word of the input message "abc" after padding is 0x61626380

#Initialize hash values:
#(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):

const32(h0(); +6(); +a(); +0(); +9(); +e(); +6(); +6(); +7(); stack0())
const32(h1(); +b(); +b(); +6(); +7(); +a(); +e(); +8(); +5(); stack0())
const32(h2(); +3(); +c(); +6(); +e(); +f(); +3(); +7(); +2(); stack0())
const32(h3(); +a(); +5(); +4(); +f(); +f(); +5(); +3(); +a(); stack0())
const32(h4(); +5(); +1(); +0(); +e(); +5(); +2(); +7(); +f(); stack0())
const32(h5(); +9(); +b(); +0(); +5(); +6(); +8(); +8(); +c(); stack0())
const32(h6(); +1(); +f(); +8(); +3(); +d(); +9(); +a(); +b(); stack0())
const32(h7(); +5(); +b(); +e(); +0(); +c(); +d(); +1(); +9(); stack0())

#Initialize array of round constants:
#(first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):
#stack0 = index to k[0]; stack1 = value to be stored
k0(stack0();stack2())
append()
{
	arrayStore32(A();stack0();stack1())
	!
	stack0() + #index++
	?~
}
appendConst(a;b;c;d;e;f;g;h)
{
	const32(stack1(); a;b;c;d;e;f;g;h; stack2())
	append()
}
appendConst(+4(); +2(); +8(); +a(); +2(); +f(); +9(); +8())
appendConst(+7(); +1(); +3(); +7(); +4(); +4(); +9(); +1())
appendConst(+b(); +5(); +c(); +0(); +f(); +b(); +c(); +f())
appendConst(+e(); +9(); +b(); +5(); +d(); +b(); +a(); +5())
appendConst(+3(); +9(); +5(); +6(); +c(); +2(); +5(); +b())
appendConst(+5(); +9(); +f(); +1(); +1(); +1(); +f(); +1())
appendConst(+9(); +2(); +3(); +f(); +8(); +2(); +a(); +4())
appendConst(+a(); +b(); +1(); +c(); +5(); +e(); +d(); +5())
appendConst(+d(); +8(); +0(); +7(); +a(); +a(); +9(); +8())
appendConst(+1(); +2(); +8(); +3(); +5(); +b(); +0(); +1())
appendConst(+2(); +4(); +3(); +1(); +8(); +5(); +b(); +e())
appendConst(+5(); +5(); +0(); +c(); +7(); +d(); +c(); +3())
appendConst(+7(); +2(); +b(); +e(); +5(); +d(); +7(); +4())
appendConst(+8(); +0(); +d(); +e(); +b(); +1(); +f(); +e())
appendConst(+9(); +b(); +d(); +c(); +0(); +6(); +a(); +7())
appendConst(+c(); +1(); +9(); +b(); +f(); +1(); +7(); +4())
appendConst(+e(); +4(); +9(); +b(); +6(); +9(); +c(); +1())
appendConst(+e(); +f(); +b(); +e(); +4(); +7(); +8(); +6())
appendConst(+0(); +f(); +c(); +1(); +9(); +d(); +c(); +6())
appendConst(+2(); +4(); +0(); +c(); +a(); +1(); +c(); +c())
appendConst(+2(); +d(); +e(); +9(); +2(); +c(); +6(); +f())
appendConst(+4(); +a(); +7(); +4(); +8(); +4(); +a(); +a())
appendConst(+5(); +c(); +b(); +0(); +a(); +9(); +d(); +c())
appendConst(+7(); +6(); +f(); +9(); +8(); +8(); +d(); +a())
appendConst(+9(); +8(); +3(); +e(); +5(); +1(); +5(); +2())
appendConst(+a(); +8(); +3(); +1(); +c(); +6(); +6(); +d())
appendConst(+b(); +0(); +0(); +3(); +2(); +7(); +c(); +8())
appendConst(+b(); +f(); +5(); +9(); +7(); +f(); +c(); +7())
appendConst(+c(); +6(); +e(); +0(); +0(); +b(); +f(); +3())
appendConst(+d(); +5(); +a(); +7(); +9(); +1(); +4(); +7())
appendConst(+0(); +6(); +c(); +a(); +6(); +3(); +5(); +1())
appendConst(+1(); +4(); +2(); +9(); +2(); +9(); +6(); +7())
appendConst(+2(); +7(); +b(); +7(); +0(); +a(); +8(); +5())
appendConst(+2(); +e(); +1(); +b(); +2(); +1(); +3(); +8())
appendConst(+4(); +d(); +2(); +c(); +6(); +d(); +f(); +c())
appendConst(+5(); +3(); +3(); +8(); +0(); +d(); +1(); +3())
appendConst(+6(); +5(); +0(); +a(); +7(); +3(); +5(); +4())
appendConst(+7(); +6(); +6(); +a(); +0(); +a(); +b(); +b())
appendConst(+8(); +1(); +c(); +2(); +c(); +9(); +2(); +e())
appendConst(+9(); +2(); +7(); +2(); +2(); +c(); +8(); +5())
appendConst(+a(); +2(); +b(); +f(); +e(); +8(); +a(); +1())
appendConst(+a(); +8(); +1(); +a(); +6(); +6(); +4(); +b())
appendConst(+c(); +2(); +4(); +b(); +8(); +b(); +7(); +0())
appendConst(+c(); +7(); +6(); +c(); +5(); +1(); +a(); +3())
appendConst(+d(); +1(); +9(); +2(); +e(); +8(); +1(); +9())
appendConst(+d(); +6(); +9(); +9(); +0(); +6(); +2(); +4())
appendConst(+f(); +4(); +0(); +e(); +3(); +5(); +8(); +5())
appendConst(+1(); +0(); +6(); +a(); +a(); +0(); +7(); +0())
appendConst(+1(); +9(); +a(); +4(); +c(); +1(); +1(); +6())
appendConst(+1(); +e(); +3(); +7(); +6(); +c(); +0(); +8())
appendConst(+2(); +7(); +4(); +8(); +7(); +7(); +4(); +c())
appendConst(+3(); +4(); +b(); +0(); +b(); +c(); +b(); +5())
appendConst(+3(); +9(); +1(); +c(); +0(); +c(); +b(); +3())
appendConst(+4(); +e(); +d(); +8(); +a(); +a(); +4(); +a())
appendConst(+5(); +b(); +9(); +c(); +c(); +a(); +4(); +f())
appendConst(+6(); +8(); +2(); +e(); +6(); +f(); +f(); +3())
appendConst(+7(); +4(); +8(); +f(); +8(); +2(); +e(); +e())
appendConst(+7(); +8(); +a(); +5(); +6(); +3(); +6(); +f())
appendConst(+8(); +4(); +c(); +8(); +7(); +8(); +1(); +4())
appendConst(+8(); +c(); +c(); +7(); +0(); +2(); +0(); +8())
appendConst(+9(); +0(); +b(); +e(); +f(); +f(); +f(); +a())
appendConst(+a(); +4(); +5(); +0(); +6(); +c(); +e(); +b())
appendConst(+b(); +e(); +f(); +9(); +a(); +3(); +f(); +7())
appendConst(+c(); +6(); +7(); +1(); +7(); +8(); +f(); +2())

#Pre-processing:
#begin with the original message of length L bits
#append a single '1' bit
#append K '0' bits, where K is the minimum number >= 0 such that L + 1 + K + 64 is a multiple of 512
#append L as a 64-bit big-endian integer, making the total post-processed length a multiple of 512 bits
#For 256-bit input, this becomes 1 chunck of [data | 0x80 | 0x00 * 29 | 0x0100]

#copy chunk into first 16 words w[0..15] of the message schedule array
#stack0 = index to w[0]; stack1 = value to be stored
w0(stack0();stack2())
read32(stack1()) append()
read32(stack1()) append()
read32(stack1()) append()
read32(stack1()) append()
read32(stack1()) append()
read32(stack1()) append()
read32(stack1()) append()
read32(stack1()) append()
appendConst(+8(); +0(); +0(); +0(); +0(); +0(); +0(); +0())
zero32(stack1())
append()
append()
append()
append()
append()
append()
appendConst(+0(); +0(); +0(); +0(); +0(); +1(); +0(); +0())


#Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:

const8(stack1()    ;+0();+3();stack3()) #stack1[0] = 3
const8(stack1() >  ;+0();+7();stack3()) #stack1[1] = 7
const8(stack1() >> ;+1();+2();stack3()) #stack1[2] = 18
const8(stack1() >>>;+1();+1();stack3()) #stack1[3] = 17
const8(stack2()    ;+1();+3();stack3()) #stack2[0] = 19
const8(stack2() >  ;+0();+8();stack3()) #stack2[1] = 8
const8(stack2() >> ;+4();+0();stack3()) #stack2[2] = 64
w0    (stack2() >>>;          stack3()) #stack2[3] = w

#for i from 16 to 63
const8(stack0();+3();+0();stack3()) #stack0[0] = 64 - i
while(stack0();
	subtract8(stack0() >;stack2() >>; stack0(); stack0() >>>) #stack0[1] = i
	#write8(stack0() >)
	ad8(stack0() >; stack2() >>>; stack3())                   #stack0[1] = w+i

	#s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)
	copy8(stack0() >; stack0() >>; stack0() >>>)
	! stack0() >> --------------- ?~         #stack0[2] = w+i-15

	arrayRetrieve32(stack3();A();stack0() >>)
	write32(stack3())
	#TODO

	#s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10)
	copy8(stack0() >; stack0() >>; stack0() >>>)
	! stack0() >> -- ?~                      #stack0[2] = w+i-2
	#TODO

	#w[i] := w[i-16] + s0 + w[i-7] + s1
	#TODO

	!? stack0() - ?~
	)

