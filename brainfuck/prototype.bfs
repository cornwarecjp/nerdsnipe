################################################################################

memDump()
{
	write()    #write *ptr
	0() +      #*ptr = 1
	[          #while *ptr
	>          #    ptr++
	write()    #    write *ptr
	0() +      #    *ptr = 1
	]
}

################################################################################

#32-bit position shifts
>1(){>>>>}
<1(){<<<<}
>2(){>1()>1()}
<2(){<1()<1()}
>4(){>2()>2()}
<4(){<2()<2()}
>8(){>4()>4()}
<8(){<4()<4()}
>16(){>8()>8()}
<16(){<8()<8()}


#Memory map
h0(){}
h1(){h0() >1()}
h2(){h0() >1() >1()}
h3(){h0() >1() >1() >1()}
h4(){h0() >1() >1() >1() >1()}
h5(){h0() >1() >1() >1() >1() >1()}
h6(){h0() >1() >1() >1() >1() >1() >1()}
h7(){h0() >1() >1() >1() >1() >1() >1() >1()}

s0(){h0() >8()}
s1(){s0() >1()}
ch(){s1() >1()}
maj(){ch() >1()}
temp1(){maj() >1()}
temp2(){temp1() >1()}

a(){temp2() >1()}
b(){a() >1()}
c(){b() >1()}
d(){c() >1()}
e(){d() >1()}
f(){e() >1()}
g(){f() >1()}
h(){g() >1()}

stack0(){h() >1()}
stack1(){stack0() >1()}
stack2(){stack1() >1()}
stack3(){stack2() >1()}

A(){stack3() >1()}
#Actual data in A starts 7 bytes later

#In A:
#m = 0x00..0x0f
m0(x;temp0){zero32(x)}
#w = 0x10..0x4f
w0(x;temp0){const32(x;+0();+0();+0();+0();+0();+0();+1();+0();temp0)}
#k = 0x50..0x8f
k0(x;temp0){const32(x;+0();+0();+0();+0();+0();+0();+5();+0();temp0)}

#Note 1: All variables are 32 bit unsigned integers and addition is calculated modulo 232
#Note 2: For each round, there is one round constant k[i] and one entry in the message schedule array w[i], 0 ≤ i ≤ 63
#Note 3: The compression function uses 8 working variables, a through h
#Note 4: Big-endian convention is used when expressing the constants in this pseudocode,
#    and when parsing message block data from bytes to words, for example,
#    the first word of the input message "abc" after padding is 0x61626380

#Initialize hash values:
#(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):

#h0 := 0x6a09e667
const32(h0(); +6(); +a(); +0(); +9(); +e(); +6(); +6(); +7(); stack0())
#h1 := 0xbb67ae85
const32(h1(); +b(); +b(); +6(); +7(); +a(); +e(); +8(); +5(); stack0())
#h2 := 0x3c6ef372
const32(h2(); +3(); +c(); +6(); +e(); +f(); +3(); +7(); +2(); stack0())
#h3 := 0xa54ff53a
const32(h3(); +a(); +5(); +4(); +f(); +f(); +5(); +3(); +a(); stack0())
#h4 := 0x510e527f
const32(h4(); +5(); +1(); +0(); +e(); +5(); +2(); +7(); +f(); stack0())
#h5 := 0x9b05688c
const32(h5(); +9(); +b(); +0(); +5(); +6(); +8(); +8(); +c(); stack0())
#h6 := 0x1f83d9ab
const32(h6(); +1(); +f(); +8(); +3(); +d(); +9(); +a(); +b(); stack0())
#h7 := 0x5be0cd19
const32(h7(); +5(); +b(); +e(); +0(); +c(); +d(); +1(); +9(); stack0())

#Initialize array of round constants:
#(first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):
k0(stack0();stack1()) #stack0 = index to k[0]; stack2 = value to be stored
appendToK(a;b;c;d;e;f;g;h)
{
	const32(stack1(); a;b;c;d;e;f;g;h; stack2())
	arrayStore8(A();stack0();stack1())
}

#appendToK(+4(); +2(); +8(); +a(); +2(); +f(); +9(); +8())


const8(stack0(); +0(); +2(); stack2()) #index = 0x02
const8(stack1(); +a(); +b(); stack2()) #value = 0xab
arrayStore8(s0();stack0();stack1())

#k[0..63] :=
#   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
#   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
#   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
#   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
#   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
#   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
#   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
#   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2

memDump()

